name: CI Optimized

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

env:
  GO_VERSION: '1.25'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Single preparation job - build once, share everywhere
  prepare:
    name: Prepare Build
    runs-on: ubuntu-latest
    outputs:
      go-cache-key: ${{ steps.cache-key.outputs.go-cache-key }}
      docker-image: ${{ steps.meta.outputs.tags }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Generate cache key
      id: cache-key
      run: |
        echo "go-cache-key=${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}" >> $GITHUB_OUTPUT

    - name: Cache Go modules and build cache
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ steps.cache-key.outputs.go-cache-key }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Generate manifests and code (once)
      run: |
        # Install tools once
        make kustomize controller-gen envtest
        # Generate everything once
        make manifests generate fmt vet

    - name: Build binaries
      run: |
        make build
        make build-kubeftpd

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: |
          bin/
          config/
          coverage.out
        retention-days: 1

    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      uses: docker/build-push-action@v6
      with:
        context: .
        push: false
        tags: ${{ steps.meta.outputs.tags }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        outputs: type=docker,dest=/tmp/image.tar

    - name: Upload Docker image
      uses: actions/upload-artifact@v4
      with:
        name: docker-image
        path: /tmp/image.tar
        retention-days: 1

  # Parallel quality checks - no building, just analysis
  quality:
    name: Quality Checks
    runs-on: ubuntu-latest
    needs: prepare
    strategy:
      matrix:
        check: [lint, security, vet]
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Restore Go cache
      uses: actions/cache/restore@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ needs.prepare.outputs.go-cache-key }}

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts

    - name: Run quality check
      run: |
        case "${{ matrix.check }}" in
          lint)
            echo "Running golangci-lint..."
            curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin latest
            $(go env GOPATH)/bin/golangci-lint run --timeout=5m
            ;;
          security)
            echo "Running gosec security scanner..."
            go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
            gosec -fmt sarif -out gosec.sarif -stdout -verbose=text ./...
            ;;
          vet)
            echo "Running go vet..."
            go vet ./...
            ;;
        esac

    - name: Upload security results
      if: matrix.check == 'security'
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: gosec.sarif

  # Parallel test matrix - no building, just testing
  tests:
    name: Tests
    runs-on: ubuntu-latest
    needs: prepare
    strategy:
      matrix:
        test-type: [unit, integration, coverage]
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Restore Go cache
      uses: actions/cache/restore@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ needs.prepare.outputs.go-cache-key }}

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts

    - name: Set up MinIO for integration tests
      if: matrix.test-type == 'integration'
      run: |
        docker run -d \
          --name minio \
          -p 9000:9000 \
          -e MINIO_ROOT_USER=minioadmin \
          -e MINIO_ROOT_PASSWORD=minioadmin123 \
          minio/minio:latest server /data
        # Wait for MinIO to be ready
        sleep 10

    - name: Run tests
      run: |
        case "${{ matrix.test-type }}" in
          unit)
            echo "Running unit tests..."
            KUBEBUILDER_ASSETS="$(pwd)/bin/k8s" go test ./internal/... -v
            ;;
          integration)
            echo "Running integration tests..."
            MINIO_ENDPOINT=http://localhost:9000 \
            MINIO_ACCESS_KEY=minioadmin \
            MINIO_SECRET_KEY=minioadmin123 \
            MINIO_BUCKET=test-bucket \
            INTEGRATION_TEST=1 \
            KUBEBUILDER_ASSETS="$(pwd)/bin/k8s" go test ./test/integration/... -v -timeout 10m
            ;;
          coverage)
            echo "Running tests with coverage..."
            KUBEBUILDER_ASSETS="$(pwd)/bin/k8s" go test ./internal/... -coverprofile=coverage.out -covermode=atomic
            go tool cover -func=coverage.out
            ;;
        esac

    - name: Upload coverage
      if: matrix.test-type == 'coverage'
      uses: codecov/codecov-action@v5
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella

  # E2E tests - reuse Docker image
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [prepare, tests]
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Create Kind cluster
      uses: helm/kind-action@v1
      with:
        cluster_name: kubeftpd-test

    - name: Download Docker image
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: /tmp

    - name: Load Docker image
      run: |
        docker load --input /tmp/image.tar
        # Tag for kind
        docker tag ${{ needs.prepare.outputs.docker-image }} kubeftpd:test
        kind load docker-image kubeftpd:test

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts

    - name: Deploy to Kind
      run: |
        kubectl apply -f config/crd/bases/
        kubectl create namespace kubeftpd-system
        kubectl apply -f config/rbac/
        # Use our built image
        sed 's|controller:latest|kubeftpd:test|g' config/manager/manager.yaml | kubectl apply -f -

    - name: Wait for deployment
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/kubeftpd-controller-manager -n kubeftpd-system

    - name: Run E2E tests
      run: |
        go test ./test/e2e/ -v -ginkgo.v

    - name: Collect logs on failure
      if: failure()
      run: |
        kubectl logs -n kubeftpd-system deployment/kubeftpd-controller-manager --all-containers=true
        kubectl describe pods -n kubeftpd-system

  # Final validation - only runs if everything passes
  validate:
    name: Final Validation
    runs-on: ubuntu-latest
    needs: [quality, tests, e2e]
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts

    - name: Validate Kubernetes manifests
      run: |
        # Install kubeval
        curl -L https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz | tar xz
        sudo mv kubeval /usr/local/bin
        # Validate all manifests
        find config -name "*.yaml" -exec kubeval {} \;

    - name: Run Trivy security scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Success notification
      run: |
        echo "ðŸŽ‰ All tests passed! Build is ready for deployment."